<!DOCTYPE html>
<html>

<head>
    <title>ZK-Hack gamma-ray</title>
    <!-- MathJax for LaTeX -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Highlight.js for Rust Code -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<style>
    body {
        font-family: Arial, sans-serif;
        /* Use a modern font */
    }

    .highlighted-text {
        background-color: rgba(255, 255, 255, 0.9);
        /* Very light background, almost white */
        color: #333;
        /* Dark grey text for contrast */
        padding: 10px;
        /* Padding inside the highlight box */
        margin: 20px 0;
        /* Margin outside the highlight box */
        border: 1px solid #aaa;
        /* Light grey border for subtle contrast */
        font-style: italic;
    }
</style>

<body>
    <h2>Problem</h2>
    <div class="highlighted-text">
        <p>Bob was deeply inspired by the Zcash design [1] for private transactions and had some pretty cool ideas on
            how to adapt
            it for his requirements. He was also inspired by the Mina design for the lightest blockchain and wanted to
            combine the
            two. In order to achieve that, Bob used the MNT6753 cycle of curves to enable efficient infinite recursion,
            and used
            elliptic curve public keys to authorize spends. He released a first version of the system to the world and
            Alice soon
            announced she was able to double spend by creating two different nullifiers for the same key...</p>
    </div>

    <h2>Hints</h2>
    <p>
    <ul>
        <li>Lemma 5.4.7 in the <a href="https://zips.z.cash/protocol/protocol.pdf">Zcash specs</a>

            mentions Bob's reasoning on why to only use the x coordinate when storing the public keys -- "" </li>

        <li>Note that the MNT curves are represented in Weierstrass from in the circuit, and use the fact that both
            (x,y) and
            (x,-y) are valid points for spending</li>


        <li>Make sure you negate the y coordinate in the right scalar field, being the base field of MNT4</li>
    </ul>

    </p>
    <h2>Elliptic Curve properties</h2>

    <p>
        MNT cycle of curves have property as, base and scalar field of one curve is the scalar field and base field
        respectively of the next curve.
    </p>






    <h2>Solution</h2>
    <p>By subtracting the original scalar from the curve order often works to find another scalar that, when multiplied
        with the
        generator of an elliptic curve, produces a point with the same x-coordinate as the original scalar does. This is
        due to
        the properties of elliptic curves over finite fields, particularly the symmetry about the x-axis</p>


    <p> For a given elliptic curve, let's denote
    <ul>
        <li>The curve order as \(n\)</li>
        <li>The original scalar as \(k\)</li>
        <li>The generator point of the curve as \(G\)</li>
    </ul>

    The point obtained by multiplying the generator
    \(G\) by the scalar

    \(k\) is denoted as \(kG=(x,y)\). Due to the symmetric nature of elliptic curves, the point

    \((x,−y)\) is also on the curve. This point can be denoted as \((nG−kG)\) because:
    </p>



    <p>
    <ol>
        <li>The order of the curve \(n\) is the total number of points on the curve.</li>
        <li>Multiplying the generator point \(G\) by the curve order n yields the identity element (point at infinity),
            so

            \(nG\) is effectively the same as the identity element.</li>

        <li>Subtracting \(kG\) from the identity element is equivalent to adding the inverse of

            \(kG\), which is \((x,−y)\).</li>


        Therefore, the scalar \(n−k\) will yield the point \((x,−y)\) when multiplied by \(G\), having the same
        x-coordinate but the negated y-coordinate.

    </ol>

    </p>



    <p> .......... TBD ...........</p>

    <h2>Rust Code</h2>
    <pre><code class="rust">
// Rust code example
    // Getting the the modulus of the MNT curve which is the curve order.
    let modulus = MNT6BigFr::MODULUS.clone();
    let leaked_secret: MNT4BigFr = from_file("./puzzle-gamma-ray/leaked_secret.bin");
    let big_int_leaked = leaked_secret.into_bigint();
    
    let int_value = BigInteger768::from(modulus);
    // let int_value2 = BigInteger768::from(modulus1);
    let leaked_sec_big_rep = BigInteger768::from(leaked_secret);
    
    let curve_order = MNT4BigFr::from(int_value);
    // let int_value2 = MNT4BigFr::from(int_value2);
    let leaked_bigint = MNT4BigFr::from(leaked_sec_big_rep);
    
    // We obtain the same secret by subtracting from curve_order
    let secret_hack = curve_order - leaked_bigint;
    
    let nullifier_hack =
    <LeafH as CRHScheme>::evaluate(&leaf_crh_params, vec![secret_hack]).unwrap();

    // Testing the points (x,y) and (x,-y) to confirm
    let g = affine::generator();
    let a = <MNT4BigFr as PrimeField>::MODULUS;
    let leaked_bigint = MNT4BigFr::from(leaked_sec_big_rep);
    
    // let neg = - (leaked_secret_bigint);
    let pubk = g.mul_bigint(&leaked_secret_bigint);
    
    dbg!(&pubk);
    dbg!(&pubk.y);
    
    let e = projective::rand(&mut rng);
    
    let e_affine = e;
    let e_x = e_affine.x;
    let e_y = e_affine.y;
    let neg_e_y = - e_y;
    let is_at_infinity = e_affine.is_zero();
    let new_e = affine::new(e_x, e_y);
    
    let neg_new_e = affine::new(e_x,neg_e_y);
    
    let new_pub = new_e.mul_bigint(&leaked_secret_bigint);
    
    let neg_pub = neg_new_e.mul_bigint(&leaked_secret_bigint);
    
    dbg!(&new_pub.z);
    dbg!(&neg_pub.z);
    </code></pre>

</body>

</html>